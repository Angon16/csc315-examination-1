
\chapter{Emily Andrulis}

\begin{enumerate}
  \item Most programming languages require the use of brackets to
    enclose the index in a reference to an element of an array.
  \begin{enumerate}
    \item Identify a language the requires the use of parentheses
      to enclose the index in a reference to an element of an array.
    \item Why did the designers of the language choose parentheses
      rather than brackets?
    \end{enumerate}

  \begin{answer}

  \begin{enumerate}
    \item Ada uses parentheses to enclose the index in a reference to an element of an array.
    \item Ada was designed this way so that array references and function calls in expressions would both use the same syntax. They wanted this uniformity because they are both mappings, and should therefore have the same syntax.
    \end{enumerate}

    \end{answer}
    
  \item What is the relationship between a lexeme and a token?

  \begin{answer}

    A token is a category of its lexemes. An identifier is a token that can have many lexemes (or instances), such as index or count, but some tokens only have a single possible lexeme, i.e. = is the only lexeme for equalSign token.

    \end{answer}

  \item
  \begin{enumerate}
    \item What kind of symbols are found at the internal nodes of a
      parse tree?
    \item What kind of symbols are found at the leaves of a parse tree?
    \end{enumerate}

  \begin{answer}

  \begin{enumerate}
    \item Internal nodes of a parse tree have a nonterminal symbol, such as id in angle brackets.
    \item Leaves of a parse tree have terminal symbols, such as A.
    \end{enumerate}

    \end{answer}


  \item One of the most significant contributions from the developers
    of ALGOL 60 also limited the success of that language. What was
    that contribution?

  \begin{answer}
    ALGOL 60 was the first programming language to use BNF, or even to formally describe the syntax of the langauge at all. Even though nowadays BNF is widely used and recognized as an acceptable way to document programming language syntax, at the time BNF was not easily accepted since most viewed it as strange and complicated.
    

    \end{answer}

  \item What problem were the creators of Common LISP trying to solve?

  \begin{answer}

    Mainly, the creaters of LISP were trying to create a language that could do list processing. In particular, they needed a language that could support recursion, conditional expressions, and dynamic storage allocation or implicit deallocation. The creaters were John McCarthy and Marvin Minsky from MIT.

    \end{answer}

  \item What is an ambiguous context free grammar?

  \begin{answer}

    An ambiguous context free grammar is one where there are two or more distinct parse trees possible for a single statement. This commonly occurs when a grammar allows parse trees to grow both from the left and the right, instead of restricting it to one side.

    \end{answer}

  \item Contrast the complexity of algorithms that can parse strings
    that conform to the most general kinds of context free grammars
    and the complexity of the algorithms that can parse strings that
    conform to the grammars of programming languages?

  \begin{answer}

    Attribute grammars are used to describe more of the structure of a programming language than can be described with a context-free grammar. Rules of static semantics are described in attribute grammars, whereas context free grammars do not take these into consideration. Therefore, algorithms that parses strings for the grammars of programming languages are more complicated because they must also account for static and dynamic semantics. However, parsing algorithms for context-free grammars must account for a large general set of grammars, and their complexity is usually measured as O(n\textsuperscript{3}). Even though programming languages are complicated, they can use parsing alogirthms that are less general and do not fit all grammars, so long as they do fit the grammar for that language. Therefore, commercial compliers have complexity of O(n) typically, which makes them less complex algorithms than those of the general context-free grammar parsing algorithms.

    \end{answer}

  \item Java represents characters with Unicode. It is the first
    widely used programming language with this feature. What is the
    significance of this feature?

  \begin{answer}

    This feature is significant because as opposed to its predeccessor, ASCII, the Unicode character set includes characters from most of the world's natural languages. Therefore, Unicode is needed to faciliate international communication with code. Also, Unicode encapsulates ASCII, and the first 128 characters of Unicode are the same as those from ASCII.

    \end{answer}

  \item How does the binary coded decimal type differ from the
    floating point type?

  \begin{answer}

    Decimal types are able to precisely store decimal numbers, within a restricted range, which cannot be done with floating point types. Although this allows more accuracy in arithmatic operations, it is also mildy wasteful with memory since they are stored one or two digits per byte. 

    \end{answer}

  \item Identify a user-defined ordinal type in the Java programming
    language.

  \begin{answer}

    Enum is the class of user-defined ordinal types in Java.

    \end{answer}

  \item Mathematicians and programmers might have different ideas
    about the precedence of Boolean operators. Explain.

  \begin{answer}

    In mathematics the OR and AND operators must have equal precedence, but in programming languages, specifically those that are C-based, a higher precedence is assigned to the AND operator over OR.

    \end{answer}

  \item Programmers should use \verb+===+ rather than \verb+==+ to
    test the equality of the values of two expressions in JavaScript. Why?

  \begin{answer}

    A double equals allows coercion first, whereas the triple equals does not.

    \end{answer}

  \item Describe a hazard of allowing short-circuited evaluation
    of expressions and side effects in expressions at the same time.

  \begin{answer}

    If a language allows short-circuited evaluation and side effects of an expression at the same time, then it is possible for a piece of the expression to not be evaluated, and therefore not have it's side effect come into play. This can be a serious problem if the evaluation of the side effect was neccessary for the program's correctness.

    \end{answer}

  \item Briefly describe the three steps in the mark-sweep algorithm
    for garbage collection.

  \begin{answer}

    Mark-sweep starts with all cells in the heap having their indicators set to indicate that they are garbage. Next, each point in the program is traced into the heap, and all reachable cells are marked instead as not being garbage. Finally, all cells in the heap that were not marked as still being in use are returned to the list of available space.

    \end{answer}

  \item What led Yukihiro Matsumoto to create the Ruby programming language?

  \begin{answer}

    He was unsatisfied with the Perl and Python languages, and wanted another language that was purely object oriented in that it did not support non-object primitive types nor functions instead of method calls.

    \end{answer}

  \item What did Microsoft aim to achieve with its development of the
    C\# language?

  \begin{answer}

    Microsoft wanted to create a language for component-based software development, specifically for such development in the .NET framework that they had already established.

    \end{answer}

  \end{enumerate}


