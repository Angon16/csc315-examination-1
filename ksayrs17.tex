
\chapter{Kat Sayrs}

\begin{enumerate}
  \item Most programming languages require the use of brackets to
    enclose the index in a reference to an element of an array.
  \begin{enumerate}
    \item Identify a language the requires the use of parentheses
      to enclose the index in a reference to an element of an array.
    \item Why did the designers of the language choose parentheses
      rather than brackets?
    \end{enumerate}

  \begin{answer}

  \begin{enumerate}
    \item Ada
    \item They chose parenthasees so that there would be uniformity between array refences and function calls in expressions, regardless of potential readability issues.
    \end{enumerate}

    \end{answer}
    
  \item What is the relationship between a lexeme and a token?

  \begin{answer}

    A lexeme is the lowest-level syntactc unit. They are partitioned into groups. 
Each lexeme group is represented by a token. So, a token is a category of its lexemes.

    \end{answer}

  \item
  \begin{enumerate}
    \item What kind of symbols are found at the internal nodes of a
      parse tree?
    \item What kind of symbols are found at the leaves of a parse tree?
    \end{enumerate}

  \begin{answer}

  \begin{enumerate}
    \item nonterminal symbols
    \item terminal symbols
    \end{enumerate}

    \end{answer}


  \item One of the most significant contributions from the developers
    of ALGOL 60 also limited the success of that language. What was
    that contribution?

  \begin{answer}

    Backus-Naur Form, or BNF, a way of describing sntax.

    \end{answer}

  \item What problem were the creators of Common LISP trying to solve?

  \begin{answer}

    The lack of portability among programs written in various dialects.

    \end{answer}

  \item What is an ambiguous context free grammar?

  \begin{answer}

    A grammar that generates a sentential form for which there are two or more distinct parse trees.

    \end{answer}

  \item Contrast the complexity of algorithms that can parse strings
    that conform to the most general kinds of context free grammars
    and the complexity of the algorithms that can parse strings that
    conform to the grammars of programming languages?

  \begin{answer}

    Parsing algorithms that work for any unambiguous grammar are complicated
and inefficient. The complexity of such algorithms is O(n3). This relatively large amount of time is required because these algorithms frequently must back up and reparse part of the sentence being analyzed.Backing up the parser also requires that part of the parsemtree being constructed must be dismantled and rebuilt.
	In terms of parsing, faster algorithms have been found that work for only a subset of the set of all possible grammars. These algorithms are acceptable as long as the subset includes grammars that describe programming languages.

    \end{answer}

  \item Java represents characters with Unicode. It is the first
    widely used programming language with this feature. What is the
    significance of this feature?

  \begin{answer}

   Unicode includes characters from most of the world's natural languages, allowing for communication among computers worldwide.

    \end{answer}

  \item How does the binary coded decimal type differ from the
    floating point type?

  \begin{answer}

    Decimal types are able to precisely store decimal values within a restricted range, which cannot be don with a floating-point. However, their storage in memory is somewhat wasteful. Floating-points are approximations, but take up less storage space in memory.

    \end{answer}

  \item Identify a user-defined ordinal type in the Java programming
    language.

  \begin{answer}

    An enumeration type.

    \end{answer}

  \item Mathematicians and programmers might have different ideas
    about the precedence of Boolean operators. Explain.

  \begin{answer}

    In mathematics, OR and AND have equal precedence, and this is the case with Ada. However, C-based languages assign AND a higher prescedence than OR, possibly resulting from a correlation between multiplication and the AND operator, and addition and OR.

    \end{answer}

  \item Programmers should use \verb+===+ rather than \verb+==+ to
    test the equality of the values of two expressions in JavaScript. Why?

  \begin{answer}

    With ==, the expressions are coerced into the same type before evaluation, but with ===, no coercion is done.

    \end{answer}

  \item Describe a hazard of allowing short-circuited evaluation
    of expressions and side effects in expressions at the same time.

  \begin{answer}

    The side effect will only occur in complete evaluations of the whole expression, so if the program depends upon that side effect for correctness and the part of the expression with the side effect is not evaluated, the program will result in a serious error and fail.

    \end{answer}

  \item Briefly describe the three steps in the mark-sweep algorithm
    for garbage collection.

  \begin{answer}

    1. All cells in the heap are indeicated as garbage.
    2. Every pointer in the program is traced to the heap, and all reachable cells are marked as not garbage anymore.
    3. sweep phase: all cells not marked as still being used are returned to the list of available space.

    \end{answer}

  \item What led Yukihiro Matsumoto to create the Ruby programming language?

  \begin{answer}

    He was dissatisfied with Perl and Python, since neither of them are pure object-oriented languages in that they have primitive types and support functions.

    \end{answer}

  \item What did Microsoft aim to achieve with its development of the
    C\# language?

  \begin{answer}

    The designers wanted to provide a language for component-based software development, specifically for such development in the .NET framework. In this environment, components from a variety of languages can be easily combined to form systems.

    \end{answer}

  \end{enumerate}


